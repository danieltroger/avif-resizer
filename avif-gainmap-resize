#!/usr/bin/env bash
# Resize AVIF -> AVIF by target width, preserving AR.
# - Gain‑map inputs: extract base (SDR) + render HDR alternate, resize both,
#   then recombine with explicit CICP so HDR is recognized.
# - Pure‑HDR inputs (PQ/HLG, no gain‑map): avoid PNG (no tonemap); decode to Y4M,
#   resize with ffmpeg, then re‑encode with original CICP/bit‑depth/YUV.

set -Eeuo pipefail

# Print failing line and command on any error
trap 'rc=$?; echo >&2; echo >&2 "[ERROR] exit $rc at line ${BASH_LINENO[0]} while running: ${BASH_COMMAND}"; exit $rc' ERR

usage() {
  cat <<EOF
Usage: $(basename "$0") -w <width> [options] <input.avif> <output.avif>

Required:
  -w, --width <px>           Target width in pixels (height auto; AR preserved)

Quality/speed (defaults):
  -q, --qcolor <0-100>       Base/Color quality (default: 55)
      --qgain  <0-100>       Gain-map quality (default: 60)
  -s, --speed  <0-10>        Encoder speed (default: 6)
      --downscaling <1|2|4>  Store gain-map at 1/x resolution (default: 2)
      --headroom <float>     HDR headroom (stops) for gain-map alt render (default: 4)
      --verbose              Trace commands and show parsed metadata

Examples:
  $(basename "$0") -w 2048 input-gainmap.avif out-gm.avif --verbose
  $(basename "$0") -w 2560 input-pq.avif      out-pq.avif --verbose
EOF
}

# ---- Defaults ----
WIDTH=""
QCOLOR="${QCOLOR:-55}"
QGAIN="${QGAIN:-60}"
SPEED="${SPEED:-6}"
DOWNSCALING="${DOWNSCALING:-2}"
HEADROOM="${HEADROOM:-4}"
VERBOSE=0

# ---- Parse args ----
while [ $# -gt 0 ]; do
  case "$1" in
    -w|--width) WIDTH="$2"; shift 2;;
    -q|--qcolor) QCOLOR="$2"; shift 2;;
    --qgain) QGAIN="$2"; shift 2;;
    -s|--speed) SPEED="$2"; shift 2;;
    --downscaling) DOWNSCALING="$2"; shift 2;;
    --headroom) HEADROOM="$2"; shift 2;;
    --verbose) VERBOSE=1; shift;;
    -h|--help) usage; exit 0;;
    *) break;;
  esac
done
if [ -z "${WIDTH}" ] || [ $# -lt 2 ]; then usage; exit 1; fi
IN="$1"; OUT="$2"

# ---- Tool checks ----
need() { command -v "$1" >/dev/null 2>&1 || { echo >&2 "[FATAL] '$1' not found in PATH"; exit 127; }; }
need avifdec; need avifenc; need avifgainmaputil; need ffmpeg; need magick

# Verbose trace if asked
if [ "$VERBOSE" -eq 1 ]; then set -x; fi

tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' EXIT

# ---- Read source metadata (CICP/bit-depth/YUV/range/CLLI) ----
read_source_info() {
  local f="$1" info
  info="$(avifdec --info "$f" 2>&1 || true)"

  # Use awk to be robust against spacing/asterisks
  SRC_P="$(awk -F: '/Color Primaries/{gsub(/[^0-9]/,"",$2);print $2; exit}' <<<"$info" || true)"
  SRC_T="$(awk -F: '/Transfer Char\./{gsub(/[^0-9]/,"",$2);print $2; exit}' <<<"$info" || true)"
  SRC_M="$(awk -F: '/Matrix Coeffs\./{gsub(/[^0-9]/,"",$2);print $2; exit}' <<<"$info" || true)"
  SRC_DEPTH="$(awk -F: '/Bit Depth/{gsub(/[^0-9]/,"",$2);print $2; exit}' <<<"$info" || true)"
  SRC_YUV="$(awk -F: '/Format/{if($2~/(YUV[0-9]+)/){match($2,/YUV([0-9]+)/,m);print m[1]}}' <<<"$info" || true)"
  SRC_RANGE="$(awk -F: '/Range/{gsub(/^[[:space:]]+|[[:space:]].*/,"",$2);print $2; exit}' <<<"$info" || true)"
  SRC_CLLI="$(awk -F: '/CLLI/{gsub(/[[:space:]]/,"",$2);print $2; exit}' <<<"$info" || true)"

  # Fallbacks (use explicit if, not &&/|| to avoid set -e pitfalls)
  if [ -z "${SRC_P}" ];     then SRC_P=1; fi
  if [ -z "${SRC_T}" ];     then SRC_T=13; fi
  if [ -z "${SRC_M}" ];     then SRC_M=6; fi
  if [ -z "${SRC_DEPTH}" ]; then SRC_DEPTH=10; fi
  if [ -z "${SRC_YUV}" ];   then SRC_YUV=444; fi
  if [ -z "${SRC_RANGE}" ]; then SRC_RANGE="Full"; fi
}
log_src() {
  [ "$VERBOSE" -eq 1 ] || return 0
  echo "[info] Source CICP P/T/M=${SRC_P}/${SRC_T}/${SRC_M}, depth=${SRC_DEPTH}, YUV=${SRC_YUV}, range=${SRC_RANGE}${SRC_CLLI:+, CLLI=${SRC_CLLI}}"
}

read_source_info "$IN"; log_src

# ---- Build avifenc flags for pure-HDR path ----
build_encode_flags() {
  ENC_FLAGS=( -q "$QCOLOR" -s "$SPEED" --cicp "${SRC_P}/${SRC_T}/${SRC_M}" )
  # These are ignored for Y4M (depth/subsampling comes from the stream), but harmless:
  ENC_FLAGS+=( --depth "${SRC_DEPTH}" --yuv "${SRC_YUV}" )
  if [ "${SRC_RANGE}" = "Full" ]; then ENC_FLAGS+=( --range full ); else ENC_FLAGS+=( --range limited ); fi
  if [ -n "${SRC_CLLI:-}" ]; then ENC_FLAGS+=( --clli "${SRC_CLLI}" ); fi
}

# ---- Gain-map vs pure-HDR branching ----
if avifgainmaputil printmetadata "$IN" >/dev/null 2>&1; then
  echo "[GM] Input has a gain-map — preserving it…"

  # Base (SDR) & Alternate (HDR) renderings (keep precision on alt)
  avifdec "$IN" "$tmp/base.png"
  avifgainmaputil tonemap "$IN" "$tmp/alt.png" --headroom "$HEADROOM" -d 16

  # Resize both identically
  magick "$tmp/base.png" -filter Lanczos -resize "${WIDTH}x" "$tmp/base_r.png"
  magick "$tmp/alt.png"  -filter Lanczos -resize "${WIDTH}x" "$tmp/alt_r.png"

  # Base keeps original CICP; alternate is explicit PQ so viewers treat it as HDR
  ALT_P="${SRC_P}"
  ALT_T=16
  ALT_M="${SRC_M}"
  if [ "$VERBOSE" -eq 1 ]; then
    echo "[info] Combine CICP — base ${SRC_P}/${SRC_T}/${SRC_M}, alt ${ALT_P}/${ALT_T}/${ALT_M}"
  fi

  avifgainmaputil combine "$tmp/base_r.png" "$tmp/alt_r.png" "$OUT" \
    --downscaling "$DOWNSCALING" --qgain-map "$QGAIN" -q "$QCOLOR" -s "$SPEED" \
    --cicp-base "${SRC_P}/${SRC_T}/${SRC_M}" \
    --cicp-alternate "${ALT_P}/${ALT_T}/${ALT_M}"

  echo "✔ Wrote (gain-map): $OUT"

else
  echo "[GM] No gain-map — preserving pure-HDR if present (avoiding SDR tonemap)."

  # Decode to Y4M (keeps YUV samples), resize in YUV, then re-encode with original CICP
  avifdec "$IN" "$tmp/in.y4m"

  # Pick pixel format consistent with source depth/YUV (yuv444p10le, etc.)
  case "${SRC_YUV}" in 444|422|420|400) ;; *) SRC_YUV=444 ;; esac
  case "${SRC_DEPTH}" in 8|10|12) ;; *) SRC_DEPTH=10 ;; esac
  FMT="yuv${SRC_YUV}p${SRC_DEPTH}le"

  ffmpeg -nostdin -hide_banner -loglevel error -y \
    -i "$tmp/in.y4m" \
    -vf "scale=${WIDTH}:-2:flags=lanczos" \
    -pix_fmt "$FMT" \
    "$tmp/out.y4m"

  build_encode_flags
  avifenc "${ENC_FLAGS[@]}" "$tmp/out.y4m" "$OUT"

  echo "✔ Wrote (pure-HDR): $OUT"
fi
