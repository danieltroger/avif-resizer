#!/usr/bin/env bash
# Resize AVIF -> AVIF by target width, preserving AR.
# - Gain‑map inputs: extract base (SDR) + render HDR alternate, resize both,
#   then recombine with explicit CICP so HDR is recognized.
# - Pure‑HDR inputs (PQ/HLG, no gain‑map): avoid PNG (no tonemap); decode to Y4M,
#   resize with ffmpeg, then re‑encode with original CICP/bit‑depth/YUV.

set -Eeuo pipefail
trap 'rc=$?; echo >&2; echo >&2 "[ERROR] exit $rc at line ${BASH_LINENO[0]} while running: ${BASH_COMMAND}"; exit $rc' ERR

usage() {
  cat <<EOF
Usage: $(basename "$0") -w <width> [options] <input.avif> <output.avif>

Required:
  -w, --width <px>           Target width in pixels (height auto; AR preserved)

Quality/speed (defaults):
  -q, --qcolor <0-100>       Base/Color quality (default: 55)
      --qgain  <0-100>       Gain-map quality (default: 60)
  -s, --speed  <0-10>        Encoder speed (default: 6)
      --downscaling <1|2|4>  Store gain-map at 1/x resolution (default: 2)
      --headroom <float>     HDR headroom (stops) for gain-map alt render (default: 4)
      --verbose              Trace + print metadata of outputs

Examples:
  $(basename "$0") -w 2048 input-gainmap.avif out-gm.avif --verbose
  $(basename "$0") -w 2560 input-pq.avif      out-pq.avif --verbose
EOF
}

# ---- Defaults ----
WIDTH=""
QCOLOR="${QCOLOR:-55}"
QGAIN="${QGAIN:-60}"
SPEED="${SPEED:-6}"
DOWNSCALING="${DOWNSCALING:-2}"
HEADROOM="${HEADROOM:-4}"
VERBOSE=0

# ---- Parse args ----
while [ $# -gt 0 ]; do
  case "$1" in
    -w|--width) WIDTH="$2"; shift 2;;
    -q|--qcolor) QCOLOR="$2"; shift 2;;
    --qgain) QGAIN="$2"; shift 2;;
    -s|--speed) SPEED="$2"; shift 2;;
    --downscaling) DOWNSCALING="$2"; shift 2;;
    --headroom) HEADROOM="$2"; shift 2;;
    --verbose) VERBOSE=1; shift;;
    -h|--help) usage; exit 0;;
    *) break;;
  esac
done
if [ -z "${WIDTH}" ] || [ $# -lt 2 ]; then usage; exit 1; fi
IN="$1"; OUT="$2"

# ---- Tools ----
need() { command -v "$1" >/dev/null 2>&1 || { echo >&2 "[FATAL] '$1' not found in PATH"; exit 127; }; }
need avifdec; need avifenc; need avifgainmaputil; need ffmpeg; need magick
if command -v gawk >/dev/null 2>&1; then AWK_BIN="gawk"; elif command -v awk >/dev/null 2>&1; then AWK_BIN="awk"; else echo >&2 "[FATAL] no awk"; exit 127; fi

# Optional tracing
if [ "$VERBOSE" -eq 1 ]; then set -x; fi

tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' EXIT

# ---- Read source metadata (CICP/bit-depth/YUV/range/CLLI) ----
read_source_info() {
  local f="$1" info
  info="$(avifdec --info "$f" 2>&1 || true)"

  SRC_P="$("$AWK_BIN" -F: '/Color Primaries/{gsub(/[^0-9]/,"",$2);print $2; exit}' <<<"$info" || true)"
  SRC_T="$("$AWK_BIN" -F: '/Transfer Char\./{gsub(/[^0-9]/,"",$2);print $2; exit}' <<<"$info" || true)"
  SRC_M="$("$AWK_BIN" -F: '/Matrix Coeffs\./{gsub(/[^0-9]/,"",$2);print $2; exit}' <<<"$info" || true)"
  SRC_DEPTH="$("$AWK_BIN" -F: '/Bit Depth/{gsub(/[^0-9]/,"",$2);print $2; exit}' <<<"$info" || true)"
  SRC_YUV="$("$AWK_BIN" -F: '/Format/{if($2~/(YUV[0-9]+)/){match($2,/YUV([0-9]+)/,m);print m[1]}}' <<<"$info" || true)"
  SRC_RANGE="$("$AWK_BIN" -F: '/Range/{gsub(/^[[:space:]]+|[[:space:]].*/,"",$2);print $2; exit}' <<<"$info" || true)"
  SRC_CLLI="$("$AWK_BIN" -F: '/CLLI/{gsub(/[[:space:]]/,"",$2);print $2; exit}' <<<"$info" || true)"

  # Fallbacks
  if [ -z "${SRC_P}" ];     then SRC_P=1; fi
  if [ -z "${SRC_T}" ];     then SRC_T=13; fi
  if [ -z "${SRC_M}" ];     then SRC_M=6; fi
  if [ -z "${SRC_DEPTH}" ]; then SRC_DEPTH=10; fi
  if [ -z "${SRC_YUV}" ];   then SRC_YUV=444; fi
  if [ -z "${SRC_RANGE}" ]; then SRC_RANGE="Full"; fi
}
log_src() {
  [ "$VERBOSE" -eq 1 ] || return 0
  echo "[info] Source CICP P/T/M=${SRC_P}/${SRC_T}/${SRC_M}, depth=${SRC_DEPTH}, YUV=${SRC_YUV}, range=${SRC_RANGE}${SRC_CLLI:+, CLLI=${SRC_CLLI}}"
}
read_source_info "$IN"; log_src

# ---- Helpers ----
build_encode_flags() {
  ENC_FLAGS=( -q "$QCOLOR" -s "$SPEED" --cicp "${SRC_P}/${SRC_T}/${SRC_M}" )
  ENC_FLAGS+=( --depth "${SRC_DEPTH}" --yuv "${SRC_YUV}" )
  if [ "${SRC_RANGE}" = "Full" ]; then ENC_FLAGS+=( --range full ); else ENC_FLAGS+=( --range limited ); fi
  if [ -n "${SRC_CLLI:-}" ]; then ENC_FLAGS+=( --clli "${SRC_CLLI}" ); fi
}
gainmaputil_supports_cicp() { avifgainmaputil combine --help 2>&1 | grep -q -- '--cicp-base'; }

# Try tonemap with the highest supported depth (16→12→10→8→0) without tripping set -e
tonemap_alt() {
  local in="$1" out="$2" head="$3"
  for d in 16 12 10 8 0; do
    set +e
    avifgainmaputil tonemap "$in" "$out" --headroom "$head" -d "$d"
    rc=$?
    set -e
    if [ $rc -eq 0 ]; then
      [ "$VERBOSE" -eq 1 ] && echo "[info] tonemap succeeded with -d $d"
      return 0
    else
      [ "$VERBOSE" -eq 1 ] && echo "[warn] tonemap -d $d failed; trying next"
    fi
  done
  echo >&2 "[FATAL] avifgainmaputil tonemap failed at all tested depths (16,12,10,8,0)"
  return 1
}

# ---- Gain-map vs pure-HDR branching ----
if avifgainmaputil printmetadata "$IN" >/dev/null 2>&1; then
  echo "[GM] Input has a gain-map — preserving it…"

  # Base (SDR) & Alternate (HDR) renderings
  avifdec "$IN" "$tmp/base.png"
  tonemap_alt "$IN" "$tmp/alt.png" "$HEADROOM"

  # Resize both identically (Lanczos)
  magick "$tmp/base.png" -filter Lanczos -resize "${WIDTH}x" "$tmp/base_r.png"
  magick "$tmp/alt.png"  -filter Lanczos -resize "${WIDTH}x" "$tmp/alt_r.png"

  # Base keeps original CICP; alternate explicit PQ so viewers treat it as HDR
  ALT_P="${SRC_P}"; ALT_T=16; ALT_M="${SRC_M}"

  if gainmaputil_supports_cicp; then
    [ "$VERBOSE" -eq 1 ] && echo "[info] Combine CICP — base ${SRC_P}/${SRC_T}/${SRC_M}, alt ${ALT_P}/${ALT_T}/${ALT_M}"
    avifgainmaputil combine "$tmp/base_r.png" "$tmp/alt_r.png" "$OUT" \
      --downscaling "$DOWNSCALING" --qgain-map "$QGAIN" -q "$QCOLOR" -s "$SPEED" \
      --cicp-base "${SRC_P}/${SRC_T}/${SRC_M}" \
      --cicp-alternate "${ALT_P}/${ALT_T}/${ALT_M}"
  else
    echo "[warn] avifgainmaputil lacks --cicp-base/--cicp-alternate; combining without explicit alt CICP."
    avifgainmaputil combine "$tmp/base_r.png" "$tmp/alt_r.png" "$OUT" \
      --downscaling "$DOWNSCALING" --qgain-map "$QGAIN" -q "$QCOLOR" -s "$SPEED"
  fi

  echo "✔ Wrote (gain-map): $OUT"
  if [ "$VERBOSE" -eq 1 ]; then
    avifgainmaputil printmetadata "$OUT" | sed -n '1,120p'
    avifdec --info "$OUT" | sed -n '1,60p'
  fi

else
  echo "[GM] No gain-map — preserving pure-HDR if present (avoiding SDR tonemap)."

  # Decode to Y4M (keeps YUV samples). Fallback to ffmpeg if avifdec can't.
  if ! avifdec "$IN" "$tmp/in.y4m"; then
    echo "[info] avifdec -> y4m failed; falling back to ffmpeg decode"
    ffmpeg -nostdin -hide_banner -loglevel error -y -i "$IN" -pix_fmt yuv444p10le "$tmp/in.y4m"
  fi

  # Pixel format consistent with source depth/YUV (e.g., yuv444p10le)
  case "${SRC_YUV}" in 444|422|420|400) ;; *) SRC_YUV=444 ;; esac
  case "${SRC_DEPTH}" in 8|10|12) ;; *) SRC_DEPTH=10 ;; esac
  FMT="yuv${SRC_YUV}p${SRC_DEPTH}le"

  ffmpeg -nostdin -hide_banner -loglevel error -y \
    -i "$tmp/in.y4m" \
    -vf "scale=${WIDTH}:-2:flags=lanczos" \
    -pix_fmt "$FMT" \
    "$tmp/out.y4m"

  build_encode_flags
  avifenc "${ENC_FLAGS[@]}" "$tmp/out.y4m" "$OUT"

  echo "✔ Wrote (pure-HDR): $OUT"
  if [ "$VERBOSE" -eq 1 ]; then
    avifdec --info "$OUT" | sed -n '1,60p'
  fi
fi
