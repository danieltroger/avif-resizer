#!/usr/bin/env bash
# Resize AVIF -> AVIF by target width, preserving aspect ratio.
# • If the input has a gain-map, we recombine a resized base + HDR alternate
#   and EXPLICITLY set CICP so viewers recognize the HDR view.
# • If the input is pure-HDR (PQ/HLG) with NO gain-map, we avoid PNG (no tonemap):
#   decode to Y4M -> resize with ffmpeg -> re-encode with original CICP/bit-depth/YUV.
#
# Requirements in the container: avifdec, avifenc, avifgainmaputil, ffmpeg, ImageMagick (magick).

set -Eeuo pipefail

# Hard fail loudly on any error, show the failing command and line.
trap 'code=$?; echo >&2 ""; echo >&2 "[ERROR] exit $code at line ${BASH_LINENO[0]} while running: ${BASH_COMMAND}"; exit $code' ERR

usage() {
  cat <<EOF
Usage: $(basename "$0") -w <width> [options] <input.avif> <output.avif>

Required:
  -w, --width <px>           Target width in pixels (height auto; AR preserved)

Quality/speed (defaults):
  -q, --qcolor <0-100>       Base/Color quality (default: 55)
      --qgain  <0-100>       Gain-map quality (default: 60)
  -s, --speed  <0-10>        Encoder speed (default: 6)
      --downscaling <1|2|4>  Store gain-map at 1/x resolution (default: 2)
      --headroom <float>     HDR headroom in stops for gain-map alt render (default: 4)
      --verbose              Print detected CICP/bit-depth/YUV and commands

Examples:
  $(basename "$0") -w 2048 input-gainmap.avif out-gm.avif --verbose
  $(basename "$0") -w 2560 input-pq.avif      out-pq.avif --verbose
EOF
}

# ---- Defaults ----
WIDTH=""
QCOLOR="${QCOLOR:-55}"
QGAIN="${QGAIN:-60}"
SPEED="${SPEED:-6}"
DOWNSCALING="${DOWNSCALING:-2}"
HEADROOM="${HEADROOM:-4}"
VERBOSE=0

# ---- Parse args ----
while [ $# -gt 0 ]; do
  case "$1" in
    -w|--width) WIDTH="$2"; shift 2;;
    -q|--qcolor) QCOLOR="$2"; shift 2;;
    --qgain) QGAIN="$2"; shift 2;;
    -s|--speed) SPEED="$2"; shift 2;;
    --downscaling) DOWNSCALING="$2"; shift 2;;
    --headroom) HEADROOM="$2"; shift 2;;
    --verbose) VERBOSE=1; shift;;
    -h|--help) usage; exit 0;;
    *) break;;
  esac
done
if [ -z "${WIDTH}" ] || [ $# -lt 2 ]; then usage; exit 1; fi
IN="$1"; OUT="$2"

# ---- Tool checks ----
need() { command -v "$1" >/dev/null 2>&1 || { echo >&2 "[FATAL] '$1' not found in PATH"; exit 127; }; }
need avifdec; need avifenc; need avifgainmaputil; need ffmpeg; need magick

# Verbose tracing of commands (optional)
if [ "$VERBOSE" -eq 1 ]; then set -x; fi

tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' RETURN

# ---- Read source metadata (CICP, depth, YUV, range, CLLI) ----
read_source_info() {
  local f="$1" info
  info="$(avifdec --info "$f" 2>&1 || true)"

  get_num() { echo "$info" | grep -Eo "$1[[:space:]]*:[[:space:]]*[0-9]+" | head -n1 | grep -Eo "[0-9]+" || true; }
  SRC_P="$(get_num "Color Primaries")"
  SRC_T="$(get_num "Transfer Char\.")"
  SRC_M="$(get_num "Matrix Coeffs\.")"
  SRC_DEPTH="$(echo "$info" | grep -Eo "Bit Depth[[:space:]]*:[[:space:]]*[0-9]+" | head -n1 | grep -Eo "[0-9]+" || true)"
  SRC_YUV="$(echo "$info" | grep -Eo "Format[[:space:]]*:[[:space:]]*YUV[0-9]+" | head -n1 | grep -Eo "[0-9]+" || true)"
  SRC_RANGE="$(echo "$info" | sed -n 's/.*Range[[:space:]]*:[[:space:]]*\(Full\|Limited\).*/\1/p' | head -n1 || true)"
  SRC_CLLI="$(echo "$info" | grep -Eo "CLLI[[:space:]]*:[[:space:]]*[0-9]+,[[:space:]]*[0-9]+" | sed 's/.*://;s/[[:space:]]//g' || true)"

  # Fallbacks if parsing fails
  [ -z "${SRC_P}" ] && SRC_P=1
  [ -z "${SRC_T}" ] && SRC_T=13
  [ -z "${SRC_M}" ] && SRC_M=6
  [ -z "${SRC_DEPTH}" ] && SRC_DEPTH=10
  [ -z "${SRC_YUV}" ] && SRC_YUV=444
  [ -z "${SRC_RANGE}" ] && SRC_RANGE="Full"
}
log_src() {
  [ "$VERBOSE" -eq 1 ] || return 0
  echo "[info] Source CICP P/T/M=${SRC_P}/${SRC_T}/${SRC_M}, depth=${SRC_DEPTH}, YUV=${SRC_YUV}, range=${SRC_RANGE}${SRC_CLLI:+, CLLI=${SRC_CLLI}}"
}

read_source_info "$IN"; log_src

# ---- Build avifenc flags for pure-HDR path ----
build_encode_flags() {
  ENC_FLAGS=( -q "$QCOLOR" -s "$SPEED" --cicp "${SRC_P}/${SRC_T}/${SRC_M}" )
  # depth and yuv are ignored for y4m input (retained from y4m), but harmless:
  ENC_FLAGS+=( --depth "${SRC_DEPTH}" --yuv "${SRC_YUV}" )
  if [ "${SRC_RANGE}" = "Full" ]; then ENC_FLAGS+=( --range full ); else ENC_FLAGS+=( --range limited ); fi
  if [ -n "${SRC_CLLI:-}" ]; then ENC_FLAGS+=( --clli "${SRC_CLLI}" ); fi
}

# ---- Gain-map vs pure-HDR branching ----
if avifgainmaputil printmetadata "$IN" >/dev/null 2>&1; then
  echo "[GM] Input has a gain-map — preserving it…"

  # Base (SDR) & Alternate (HDR) renderings; keep high precision for alt
  avifdec "$IN" "$tmp/base.png"
  avifgainmaputil tonemap "$IN" "$tmp/alt.png" --headroom "$HEADROOM" -d 16

  # Resize both identically (Lanczos), width-only keeps AR
  magick "$tmp/base.png" -filter Lanczos -resize "${WIDTH}x" "$tmp/base_r.png"
  magick "$tmp/alt.png"  -filter Lanczos -resize "${WIDTH}x" "$tmp/alt_r.png"

  # Use the base's original CICP; make alternate explicit PQ (16) so HDR is recognized
  ALT_P="${SRC_P}"
  ALT_T=16
  ALT_M="${SRC_M}"
  [ "$VERBOSE" -eq 1 ] && echo "[info] Combine CICP — base ${SRC_P}/${SRC_T}/${SRC_M}, alt ${ALT_P}/${ALT_T}/${ALT_M}"

  avifgainmaputil combine "$tmp/base_r.png" "$tmp/alt_r.png" "$OUT" \
    --downscaling "$DOWNSCALING" --qgain-map "$QGAIN" -q "$QCOLOR" -s "$SPEED" \
    --cicp-base "${SRC_P}/${SRC_T}/${SRC_M}" \
    --cicp-alternate "${ALT_P}/${ALT_T}/${ALT_M}"

  echo "✔ Wrote (gain-map): $OUT"

else
  echo "[GM] No gain-map — preserving pure-HDR if present (avoiding SDR tonemap)."

  # Decode to Y4M (YUV4MPEG2). avifdec supports .y4m output. 
  avifdec "$IN" "$tmp/in.y4m"

  # Pick pixel format consistent with source depth/YUV (e.g., yuv444p10le)
  case "${SRC_YUV}" in 444|422|420|400) ;; *) SRC_YUV=444 ;; esac
  case "${SRC_DEPTH}" in 8|10|12) ;; *) SRC_DEPTH=10 ;; esac
  FMT="yuv${SRC_YUV}p${SRC_DEPTH}le"

  # Resize in YUV without color transforms; keep AR with height=-2
  ffmpeg -nostdin -hide_banner -loglevel error -y \
    -i "$tmp/in.y4m" \
    -vf "scale=${WIDTH}:-2:flags=lanczos" \
    -pix_fmt "$FMT" \
    "$tmp/out.y4m"

  build_encode_flags
  avifenc "${ENC_FLAGS[@]}" "$tmp/out.y4m" "$OUT"

  echo "✔ Wrote (pure-HDR): $OUT"
fi
